import sys

# PUNIX ITSELF #
sys.stdout.write("GETTING DATA...")
sys.stdout.flush()

data = 'add [varname] [varvalue]\nHow to use add:\n    add will create a system variable called [varname]. If you type %[varname] it will replace %[varname] with [varvalue]%%%%%%List of commands:\n    help   - displays infomation of a command\n    echo   - repeats and input\n    dump   - displays a file\n    edit   - primitive file editing\n    cls    - clears the screen\n    cd     - Enter working directory\n    ld     - Leave directory\n    mkdir  - makes a directory\n    mkfile - makes a file\n    rmv    - removes a file or folder\n    move   - moves a file\n    rename - renames a file\n    add    - adds a variable (Refer to them using %[variabke name])\n    set    - sets the value of a variable (do not use %)\n    del    - rmeoves a variable (do not use %)\n    if     - conditionals\n    write  - writes to a file\n    clear  - clears a file\n    rep    - repeats an action\n    for    - repeats an action and sets %a to a filename (view the help page)\n    btp    - convets a txt file into a pnx file (ONLY FOR ADVANCED USERS)\n\nFor further infomation type help [commandname] (e.g. "help echo")%%%%%%btp [file]\nHow to use btp:\n    btp will convert a .txt file into a .pnx file\n    you can run .pnx files from the command line as if they were a built in command\n\n    [ONLY FOR ADVANCED USERS]%%%%%%cd [path]\nChanges the working directory to path\n   cd downloads means all operations will be done inside of downloads%%%%%%clear [file]\nhow to use clear:\n    clear will clear [file]\n    No data will be left\n    \n    [ONLY FOR ADVANCED USERS]%%%%%%cls\n   Will clear the screen%%%%%%del [varname]\nHow to use del\n    del will delete a variable\n    >add egg 10\n    >echo %egg\n    10\n    >del egg\n    >echo %egg\n    %egg             : egg variable gone%%%%%%dump [path] *[format]\nHow to use dump:\n    the file name after dump will have all its contents displayed to the console.\n    format is usually retrieved automatically but you can override it using:\n        --raw   | -r : displays all the text\n        --basic | -b : formats the text to display properly with Punix text editor%%%%%%echo [words...\nHow to use echo?\n    Simply type something after echo and it will say it\n%%%%%%edit [path]\nHow to use the Punix text editor:\n    To add a line simply type said line.\n    You can set a line number by prefixing the line with a number.\n    Save by typing @w.\n    To leave the editor without saving, type @q. To leave and save, type @wq.\n\nEXAMPLES:\n    10 Hello world    - Would right Hello world at line ten (blank lines are ignored)\n    5 Sup peeps       - Would put Sup peeps at line 5 which is before ten, meaning it would show before hello world.\n    5 Formal          - Would overwrite Sup peeps with Formal\n    @wq               - Would save the file and quite the program.%%%%%%for [path (can be blank)] do [code]\nhow to use for\n    for will act just like rep but will instead loop of every item in [path]\n    %a will equal the current file the code is on and %i will equal the iteration\n    "for temp do rmv %a" would delete everything inside temp%%%%%%Bruh why, like what did you think this would do?%%%%%%if [condition] [code]\nHow to use if:\n    if will only run [code] if [condition] is true\n    condition can not have any spacebars\n    Valid: 1==1\n    Invalid : 1 == 1\n    Possible operators are:\n        ==   equal\n        <    less\n        >    greater\n        <-   inside\n        <!   not inside\n    for example:\n    >if data<-dat echo data contains dat\n    data contains data\n\n    >if data==data echo data\n    data\n\n    >if 4<5 echo 4<5\n    4<5%%%%%%ld\nReturns to the previous directory\n   C:/downloads/ -> ld -> C:/\n%%%%%%mkdir [path+name]\n    will create a directory%%%%%%mkfile [path+name]\n    will create a file at path with the name [name]\n    to edit these files use the punix editor%%%%%%move [file] [directory]\nHow does Move work:\n    move moves [file] into [directory] easy file moving B)%%%%%%rename [file] [new_name]\nHow does rename work:\n    rename will change the name of [file] to [new_name]\n    it is reccomend to NOT use rename from outside the directory containing [file] unless you understand the code behind punix%%%%%%rep [iterations] [code]\nHow to use rep:\n    rep will reapeat [code] [iterations] times. %i will equal the iteration the code is currently on.\n    code could be anything (it is recommended to not use for or rep inside)\n    >rep 10 echo %i\n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10%%%%%%rmv [path]\n    will delete a file or folder off of punix%%%%%%set [varname] [varvalue]\nHow to use set:\n    set will change the value of a pre existing variable\n    add egg 10    : %egg = 10\n    set egg 12    : %egg = 12%%%%%%write [file] [text]\nHow to use write:\n    write will write [text] to [file]'

files = data.split("%%%%%%")
names = ["add", "all", "btp", "cd", "clear", "cls", "del", "dump", "echo", "edit", "for", "help", "if", "ld", "mkdir", "mkfile", "move", "rename", "rep", "rmv", "set", "write"]

punix = '#     PUNIX VER 2     #\n#  AUTHOR RADARSLIME  #\nimport os, errno, sys, shutil\nfrom getpass import getuser\n\ndef none_function(value):\n    return value\ndef snip(string, start, end, format_option=none_function):\n    snip = format_option(string[start+1:end])\n    usnip = string[start:end+1]\n    return snip, usnip   \ndef snips(string, start, end, format_option=none_function):\n    snips = []\n    unformatted_snips = []\n    starts = []\n    ends = []\n    level = 0\n    if len(start) != 1 or len(end) != 1: return [], [], "BAD PARAMS"\n    i = 0\n    while i < len(string):\n        char = string[i]\n        if char == end:\n            level -= 1\n            if level == 0:\n                ends.append(i)\n            \n        if char == start:\n            level += 1\n            if level == 1:\n                starts.append(i)\n        i += 1\n    if len(starts)!=len(ends): return [], [], "INVALID STRING FORMAT"\n    i = 0\n    while i < len(starts):\n        sn, usn = snip(string, starts[i], ends[i], format_option)\n        snips.append(sn)\n        unformatted_snips.append(usn)\n        i += 1\n    return snips, unformatted_snips, "0"  \ndef mesh(list1, list2):\n    fin = []\n    i = 0\n    while i < len(list1):\n        fin.append((list1[i], list2[i]))\n        i += 1\n    return fin\ndef smkdir(path):\n    try:\n        if not os.path.isdir(path): os.mkdir(path)\n    except OSError: pass\ndef index_all(string, char):\n    indexes = []\n    last_index = 0\n    while True:\n        try:\n            last_index = string.index(char, last_index) + 1\n            indexes.append(last_index - 1)\n        except:\n            break\n    return indexes\ndef set_var(name, newval, variables):\n    i = 0\n    while i < len(variables[0]):\n        if variables[0][i] == name:\n            variables[1][i] = newval\n        i += 1\ndef get_var(name, variables):\n    i = 0\n    while i < len(variables[0]):\n        if variables[0][i] == name:\n            return variables[1][i]\n        i += 1\ndef check_disk():\n    Checks = True\n    while 1==1:\n        if not os.path.exists("C:/punix/PunixData"):\n            Checks = False\n            break\n        if not os.path.exists("C:/punix/PunixData/Help"):\n            Checks = False\n            break\n        if not os.path.exists("C:/punix/PunixData/ExtraCommands"):\n            Checks = False\n            break\n        if not os.listdir("C:/punix/PunixData/Help") == [\'add.txt\', \'all.txt\', \'btp.txt\', \'cd.txt\', \'clear.txt\', \'cls.txt\', \'del.txt\', \'dump.txt\', \'echo.txt\', \'edit.txt\', \'for.txt\', \'help.txt\', \'if.txt\', \'ld.txt\', \'mkdir.txt\', \'mkfile.txt\', \'move.txt\', \'rename.txt\', \'rep.txt\', \'rmv.txt\', \'set.txt\', \'write.txt\']:\n            Checks = False\n            break\n        break\n    return Checks\nclass user:\n    \n    def __init__(self, name, path, datafile):\n        if not os.path.isdir(path):\n            try:\n                os.mkdir(path)\n            except OSError as ose:\n                if ose.errno != errno.ENOSPC: print("Creation Of User Data Failed")\n\n        dataFileContents = open(datafile, "w+").read().split("\\n")\n        self.path = path\n        self.name = name\n        self.age  = dataFileContents[0]\n        self.datafile = datafile\n        self.do_not_delete = [self.path + "downloads",self.path + "temp",self.path + "inbox",self.path + "programData"]                                 \n        smkdir(path + "/downloads")\n        smkdir(path + "/inbox")\n        smkdir(path + "/programData")\n        if os.path.isdir(path + "/insta"): os.rename(path + "/insta",path + "/temp")\n        else: smkdir(path + "/temp")\n    def end(self):\n        write_contents = self.age\n        open(self.datafile, "w").write(write_contents)      \ndef internal_user(u, p):\n    dataPath = p + "/PunixData/" + u + "/"\n    return user(u, dataPath, dataPath + "/userData.dat")\ndef load_user(username, password):\n    path = "C:/punix"\n    passwords = open(path + "/PunixInternals/Punix2Passwords.txt").read().split("\\n")\n    for i in passwords:\n        curr_section = i.split(":")\n        if curr_section[0] == username:\n            if curr_section[1] == password: return internal_user(username, path)\n            else: return "BADPWS"\n    return None\ndef new_user(username, password):\n    path = "C:/punix"\n    open(path + "/Punix2Passwords.txt", "a").write("\\n" + username + ":" + password)\n    return internal_user(username, path)\ndef solve(ustring):\n    string = ustring.replace(" ", "")\n    lexxed_string = []\n    number = ""\n    ntype = ""\n    i = 0\n    while i < len(string):\n        if string[i] == "+":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("PLS")\n        elif string[i] == "-":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("MIN")\n        elif string[i] == "*":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("MUL")  \n        elif string[i:i + 2] == "/^":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("SQR")\n            i += 1\n        elif string[i] == "/":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("DIV")\n        elif string[i] == "^":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("POW")   \n        elif string[i] == "<":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("LES") \n        elif string[i] == ">":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("GRA")\n        elif string[i:i + 2] == "==":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("EQU")\n            i += 1  \n        elif string[i:i + 2] == "!=":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("NQU")\n            i += 1 \n        elif string[i:i + 2] == "<=":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("GRE")\n            i += 1\n        elif string[i:i + 2] == ">=":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("LEE")\n            i += 1\n        elif string[i:i + 2] == "<-":\n            lexxed_string.append(ntype + number)\n            number = ""\n            lexxed_string.append("CON")\n            i += 1\n        elif string[i] == ".":\n            ntype = "FLT"\n            number += "."\n        else:\n            if number == "":\n                ntype = "INT"\n            number += string[i]\n            \n        try: int(number)\n        except: ntype = "STR"\n        i += 1\n    lexxed_string.append(ntype + number)\n    current_number = 0\n    number = 0\n    operator = ""\n    for i in lexxed_string:\n        if i in "PLS MIN MUL DIV POW SQR EQU NQU GRA LES GRE LEE CON":\n            operator = i\n        else:\n            if i[:3] == "INT": number = int(i[3:])\n            if i[:3] == "FLT": number = float(i[3:])\n            if i[:3] == "STR": number = i[3:]\n            if operator != "":\n                try: int(current_number)\n                except: number = str(number)\n                if operator == "PLS": current_number += number\n                elif operator == "MIN": current_number -= number\n                elif operator == "MUL": current_number *= number\n                elif operator == "DIV": current_number /= number\n                elif operator == "POW": current_number = pow(current_number, number)\n                elif operator == "SQR": current_number = pow(current_number, 1/number)\n                elif operator == "EQU": current_number = int(current_number == number)\n                elif operator == "NQU": current_number = int(not (current_number == number))\n                elif operator == "GRA": current_number = int(current_number > number)\n                elif operator == "LES": current_number = int(current_number < number)\n                elif operator == "GRE": current_number = int(current_number >= number)\n                elif operator == "LEE": current_number = int(current_number <= number)\n                elif operator == "CON": current_number = int(number in current_number)\n            else: current_number = number\n    return current_number\ndef recursive_solve(string):\n    fstring = string\n    requ, replace, code = snips(string, "(", ")")\n    for equ, change in mesh(requ, replace):\n        ans = str(recursive_solve(equ))\n        fstring = fstring.replace(change, ans, 1)\n    return solve(fstring)\ndef calc_format(inp):\n    finp = inp\n    equations = []\n    answers = []\n    starts = index_all(inp, "{")\n    ends = index_all(inp, "}")\n    if len(starts) == len(ends):\n        i = 0\n        while i < len(starts):\n            start = starts[i]\n            end = ends[i]\n            ans = recursive_solve(inp[start+1:end])\n            equations.append(finp[start:end+1])\n            answers.append(str(ans))\n            i += 1\n    i = 0\n    try:\n        while i < len(equations):\n            finp = finp.replace(equations[i], answers[i])\n            i += 1\n    except: pass\n    return finp\ndef texteditor(path, maxsize=1000):\n    print("=======PUNIX TEXT EDITOR=======")  \n    sudo_file_contents = []\n    save = False\n    file = open(path, "a+")\n    file.seek(0)\n    file_contents = ""\n    try: file_contents = "\\n".join(file.read().split("\\n")[1:])\n    except: pass\n    file.close()\n    sudo_file_contents = []\n    i = len(file_contents)      \n    while i < maxsize:\n        sudo_file_contents.append("!_$")\n        i += 1\n    error = False\n    si = []\n    for i in file_contents.split("\\n"):\n        try:\n            if i != "":\n                si = i.split()\n                sudo_file_contents[int(si[0])] = " ".join(si)\n        except:\n            print("!!! INVALID FILE FORMAT !!!")\n            error = True\n            break\n    if file_contents != "": print("")\n    print(file_contents)\n    last_line = None\n    try: last_line = int(si[0])\n    except: last_line = 0\n    while True:\n        if error: break\n        inp = input("")\n        if inp == "@q":\n            if input("Do you want to quit without saving? [Y/N]") == "Y":\n                save = False\n                break\n        if inp == "@wq":\n            save = True\n            break\n        if inp == "@w":\n            open(path, "w").write("BSIC\\n" + "\\n".join(sudo_file_contents).replace("\\n!_$", "").replace("!_$\\n", ""))\n            continue\n        if inp == "":\n            continue\n        split = inp.split()\n        line = " ".join(split)\n        try: line_number = int(split[0])      \n        except:\n            line_number = last_line + 1\n            line = str(line_number) + " " + line         \n        sudo_file_contents[line_number] = line\n        last_line = line_number          \n    if save: open(path, "w").write("BSIC\\n" + "\\n".join(sudo_file_contents).replace("\\n!_$", "").replace("!_$\\n", ""))\ndef get_path(local_user, current_dir, path="", override=False):\n    user_path = local_user\n    try: user_path = local_user.path\n    except: pass\n    sudo_path = path\n    sudo_dir = current_dir\n    if path[:2] == "P:":\n        sudo_path = path[2:]\n        sudo_dir = ""\n    sudo_dir = user_path + sudo_dir\n    if path[:2] == "C:":\n        sudo_path = path[2:]\n        sudo_dir = "C:/punix/PunixData"\n    out = sudo_dir + sudo_path\n    while "//" in out: out = out.replace("//", "/")\n    if os.path.exists(out) or override: return out\n    else: return "ERROR"\ndef command(inp, local_user, lworking_directory, variables, a="%a", pref=-1, fa="%f"):\n    working_directory = lworking_directory[0]\n    finp = inp.replace("//", "/").replace("%a", str(a)).replace("%f", str(fa))\n    try: finp = finp[:finp.index("#")]\n    except: pass\n    i = 0\n    while i < len(variables[0]):\n        finp = finp.replace("%" + variables[0][i], variables[1][i])\n        i+=1\n    if pref != -1: finp = finp.replace("%i", str(pref))\n    if not finp[0] == "@":\n        try: finp = calc_format(finp)\n        except: pass\n    else: finp = finp[1:]\n    spl = finp.split()\n    com = spl[0]\n    args = []\n    if len(spl[1:]) > 0: args = spl[1:]\n    if com == "cd":\n        path = get_path("", working_directory, args[0], True) + "/"\n        if os.path.exists(local_user.path + path):\n            lworking_directory[0] = path\n            set_var("cd", "P:" + working_directory.replace("//", "/"), variables)\n    elif com == "ld":\n        try: lworking_directory[0] = "/".join(working_directory.split("/")[:-2])\n        except: pass\n        set_var("cd", "P:" + working_directory.replace("//", "/"), variables)\n    elif com == "exe_py":\n        try: os.system("python "+local_user.path+" ".join(args[0:]))\n        except: print("EXECUTION ERROR!")\n    elif com == "mkdir":\n        smkdir(get_path(local_user, working_directory, args[0], True))\n    elif com == "mkfile":\n        try: open(get_path(local_user, working_directory, args[0], True), "x")\n        except FileExistsError: pass\n    elif com == "rmv":\n        spe = get_path(local_user, working_directory, args[0])\n        override = ""\n        try: override = args[1]\n        except: pass\n        if os.path.isdir(spe):\n            if override == "-o": shutil.rmtree(spe, ignore_errors=True)\n            else:\n                conf = input("ARE YOU SURE YOU WANT TO DELETE " + args[0] + "? [Y/N]")\n                if conf == "y" or conf == "Y": shutil.rmtree(spe)\n        else:\n            if override == "-o":\n                if os.path.exists(spe) and not os.path.isdir(spe): os.remove(spe)\n            else:\n                conf = input("ARE YOU SURE YOU WANT TO DELETE " + args[0] + "? [Y/N]")\n                if conf == "y" or conf == "Y":\n                    if os.path.exists(spe) and not os.path.isdir(spe): os.remove(spe)\n    elif com == "echo":\n        path = sys.stdout\n        text = args[:]\n        try:\n            if args[-2] == ">":\n                path = open(get_path(local_user, working_directory, args[-1]), "a")\n                text = args[:-2]\n        except: pass\n        print(" ".join(text), file=path)\n    elif com == "cls":\n        os.system("cls")\n    elif com == "add":\n        variables[0].append(args[0])\n        variables[1].append(" ".join(args[1:]))\n    elif com == "set":\n        i = 0\n        while i < len(variables[0]):\n            if variables[0][i] == args[0]: variables[1][i] = " ".join(args[1:])\n            i += 1\n    elif com == "del":\n        i = 0\n        while i < len(variables[0]):\n            if variables[0][i] == args[0]:\n                variables[1].pop(i)\n                variables[0].pop(i)\n    elif com == "edit":\n        maxsize = 1000\n        try: maxsize = int(args[1])\n        except: pass\n        texteditor(get_path(local_user, working_directory, args[0], True), maxsize)\n        print("")\n    elif com == "dump":\n        file = "@EMPTY"\n        try: file = open(get_path(local_user, working_directory, args[0]))\n        except: pass\n        if file != "@EMPTY":\n            raw_file_contents = file.read()\n            file.seek(0)\n            file_format = file.readline()[:4]\n            file_contents = "\\n".join(raw_file_contents.split("\\n")[1:])\n            dtype = ""\n            try: dtype = args[1]\n            except: pass\n            if dtype == "-r" or dtype == "--raw":\n                print(raw_file_contents)\n            elif dtype == "-b" or dtype == "--basic" or file_format == "BSIC":\n                for line in file_contents.split("\\n"):\n                    print(" ".join(line.split()[1:]))\n                \n            else: print(raw_file_contents)\n            file.close()\n        else: print("NO FILE NAMED " + args[0])\n    elif com == "dir":\n        path = get_path(local_user, working_directory)\n        try: path = get_path(local_user, working_directory, args[0])\n        except: pass\n        if os.path.isdir(path):\n            directories = os.listdir(path)\n            for i in directories:\n                print("   " + i)        \n    elif com == "if":\n        if args[0] == "1" or args[0] == "!0":\n            rep_commands = " ".join(args[1:]).split(";")\n            for rep in rep_commands: command(rep.strip(), local_user, lworking_directory, variables, "%a", i)\n    elif com == "write":\n        file = get_path(local_user, working_directory, args[0])\n        if os.path.exists(file):\n            with open(file, "a") as f: f.write(" ".join(args[1:]))\n    elif com == "clear":\n        try: open(get_path(local_user, working_directory, args[0]), "w")\n        except: pass\n    elif com == "rep":\n        count = int(args[0]) + 1\n        rep_command = " ".join(args[1:])\n        i = 1\n        while i < count:\n            rep_commands = rep_command.split(";")\n            for rep in rep_commands: command(rep.strip(), local_user, lworking_directory, variables, "%a", i)\n            i += 1\n    elif com == "for":\n        path = get_path(local_user, working_directory)\n        rep_command = ""\n        if args[0] == "do": rep_command = " ".join(args[1:])\n        elif args[1] == "do":\n            path = get_path(local_user, working_directory, args[0])\n            rep_command = " ".join(args[2:])\n        dirs = os.listdir(path)\n        i = 0\n        count = len(dirs) - 1\n        while i < count:\n            rep_commands = rep_command.split(";")\n            for rep in rep_commands:\n                try: command(rep.strip(), local_user, lworking_directory, variables, dirs[i], i, path.replace("C:/punix/PunixData", "C:") + dirs[i])\n                except: pass\n            i += 1\n    elif com == "join":\n        i = 0\n        while i < len(variables[0]):\n            if variables[0][i] == args[0]: variables[1][i] += " ".join(args[1:])\n            i += 1\n    elif com == "rename":\n        spe_file = get_path(local_user, working_directory, args[0])\n        path = "/".join(spe_file.split("/")[:-1]) + "/"\n        re_file = path + args[1].split("/")[-1]\n        if os.path.exists(spe_file): os.rename(spe_file, re_file)\n    elif com == "btp":\n        path = get_path(local_user, working_directory, args[0])\n        npath = get_path(local_user, working_directory, args[0]).split(".")[0] + ".pnx"\n        file_data = open(path).read().split("\\n")\n        file_data.pop(0)\n        output = []\n        for i in file_data:\n            line = i.split()\n            output.append(" ".join(line[1:]))\n        open(npath, "w").write("\\n".join(output))\n    elif com == "move":\n        try:\n            spe_file = get_path(local_user, working_directory, args[0])\n            re_l = get_path(local_user, working_directory, args[1])\n            re_file = re_l + args[0]\n            if os.path.exists(spe_file) and os.path.exists(re_l): shutil.move(spe_file, re_file)\n            else: print("INVALID FILE AND/OR DIRECOTRY NAME")\n        except IndexError: print("MISSING ARGUMENTS")\n    elif com == "help":\n        hfile = "C:/punix/PunixData/Help/" + args[0] + ".txt"\n        if os.path.exists(hfile): print("\\n" + open(hfile).read() + "\\n")\n        else: print("NO HELP FILE NAMED " + args[0])\n    elif com == "copy":\n        try:\n            spe_file = get_path(local_user, working_directory, args[0])\n            re_l = get_path(local_user, working_directory, args[1])\n            re_file = re_l\n            if not os.path.isdir(spe_file): re_file = re_l + args[0]\n            if os.path.exists(spe_file) and os.path.exists(re_l):\n                if os.path.isdir(spe_file): shutil.copytree(spe_file, re_file)\n                else: shutil.copy(spe_file, re_file)\n            else: print("INVALID FILE AND/OR DIRECOTRY NAME")\n        except IndexError: print("MISSING ARGUMENTS")\n    elif com == "help":\n        hfile = "C:/punix/PunixData/Help/" + args[0] + ".txt"\n        if os.path.exists(hfile): print("\\n" + open(hfile).read() + "\\n")\n        else: print("NO HELP FILE NAMED " + args[0])\n    else:\n        ranCode = False\n        otherfiles = os.listdir(local_user.path + working_directory)\n        otherfiles.extend(os.listdir("C:/punix/PunixData/ExtraCommands"))\n        pnx_files = []\n        argv = []\n        try: argv = args[0:]\n        except: pass\n        argvl = [str(f+1) for f in range(len(argv))]\n        sys_var = [argvl, argv]\n        for i in otherfiles:\n            try:\n                extension = i.split(".")[1]\n                if extension == "pnx": pnx_files.append(i)\n            except: pass\n        for i in pnx_files:\n            if i == com + ".pnx":\n                lineNumber = 1\n                if os.path.exists("C:/punix/PunixData/ExtraCommands/" + i):\n                    for i in open("C:/punix/PunixData/ExtraCommands/" + i).read().split("\\n"):\n                        try:\n                            command(i, local_user, lworking_directory, sys_var)\n                            ranCode = True\n                        except:\n                            print("ERROR OCCURED AT LINE " + str(lineNumber))\n                            break\n                        lineNumber += 1\n                elif os.path.exists(local_user.path + working_directory + i):\n                    for i in open(local_user.path + working_directory + i).read().split("\\n"):\n                        try:\n                            command(i, local_user, lworking_directory, sys_var)\n                            ranCode = True\n                        except:\n                            print("ERROR OCCURED AT LINE " + str(lineNumber))\n                            break\n                        lineNumber += 1\n        if not ranCode and com[0] == "!": print(com[1:] + " " + " ".join(args))\n    return variables\ndef main():\n    current_username = "admin"\n    password = "1324"\n    local_user = load_user(current_username, password)\n    if local_user == None:\n        if input("do you want to create a new user?") == "Y": local_user = new_user(current_username, password)\n    if local_user == "BADPWS":\n        print("Invalid Password\\n")\n        return "BADPWS"\n    if local_user != None:\n        print("PUNIX VERSION 2")\n        print("DATE OF CREATION: 5:24 PM 30/09/2021")\n        print("type \'help all\' for help")\n        print("==========================================================================")\n        working_directory = [""]\n        variables = [["cd"],["P:"]]\n        while True:\n            if check_disk():\n                inp = input("P:/" + working_directory[0] + ">")\n                if inp == "end":\n                    local_user.end()\n                    break\n                if inp == "": continue\n                if inp[0] == "#": continue\n                try: variables = command(inp, local_user, working_directory, variables)\n                except : print("Error occoured")\n                set_var("cd", "P:" + working_directory[0], variables)\n            else:\n                print("==========================================================================\\nFATAL MEMORY CORRUPTION, PLEASE REINSTALL PUNIX OR LOAD A BACKUP")\n                return "FMEMC"\n        local_user.end()\n        print("==========================================================================\\nThanks for using Punix!")        \n        return "BLANK"\n    print("==========================================================================\\nNo user detected")\n    return "NOUSR"\nif __name__ == "__main__":\n    clear_on_start = False\n    try: clear_on_start = (sys.argv[1]=="-c")\n    except:pass\n    if clear_on_start: os.system("cls")\n    print("==========================================================================")\n    print("Running Internal Checks...", end="")\n    if check_disk():\n        print("Done\\n==========================================================================")\n        print("output code : ["+main(), end="]\\n==========================================================================\\n")\n    else:\n        print("System Checks Failed, Please Reinstall Punix or load a backup to fix\\n==========================================================================")\nelse:\n    print("called []")\n    main()\n'

bat_p = '@echo off\nIF %1.==. GOTO No1\npython C:/punix/PunixInternals/Punix2.py %1\nGOTO end\n:No1\npython C:/punix/PunixInternals/Punix2.py y\n:end '

bat_pr = '@echo off\nIF %1.==. GOTO No1\npython C:/Backup/punix2/PunixInternals/PunixRestore.py %1\nGOTO end\n:No1\n pythonC:/Backup/punix2/PunixInternals/PunixRestore.py\n:end \n'

# HELP FILES #

# SAFE MAKE DIRECTORY #

sys.stdout.write("DONE\n")

sys.stdout.write("ADDING CORE FOLDERS...")
sys.stdout.flush()

import os

def smkdir(path):
    try:
        if not os.path.isdir(path): os.mkdir(path)
    except OSError: pass

smkdir("C:/punix")
smkdir("C:/punix/PunixData")
smkdir("C:/punix/PunixInternals")
smkdir("C:/punix/PunixData/Help")
smkdir("C:/punix/PunixData/ExtraCommands")

sys.stdout.write("DONE\n")

sys.stdout.write("INSTALLING PUNIX...")
sys.stdout.flush()
open("C:/punix/Punix.bat", "w").write(bat_p)
open("C:/punix/PunixRestore.bat", "w").write(bat_pr)

des = "C:/punix/PunixInternals/"

open(des + "Punix2Passwords.txt", "w").write("admin:1324\n")

try: des = sys.argv[1] + "/"
except IndexError: pass

open(des + "Punix2.py", "w").write(punix)

sys.stdout.write("DONE\n")

sys.stdout.write("ADDING HELP FILES...")
sys.stdout.flush()
help_path = "C:/punix/PunixData/Help/"

i = 0
while i < len(files):
    open(help_path + names[i] + ".txt", "w").write(files[i])
    i += 1

sys.stdout.write("DONE, hope you enjoy Punix, To load punix simply go to your local disk [C:] and open [punix], then double click [punix.bat]\n\n(Recommended to also download PunixRestore.py and insert it into PunixInternals)\n")
